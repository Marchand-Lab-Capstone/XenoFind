"""
consensus_methods.py 
J. Sumabat, N. Lai, S. Peck, Y. Huang, 3/12/2024

consensus_methods.py contains the primary methods involved in forming a first-pass
consensus on a DNA sequence with potential XNA bases. 

basecall_command() - Generates a command to run basecalling on pod5 reads using dorado
map_to_reference() - Generates a command to map a basecalled sequence to a reference fasta
vsearch_command() - Generates a command to run cluster vsearch on a fasta file
medaka_consensus_command() - Generates a command to run medaka's consensus on a fasta file.
read_trim() - Generates a list of reads that are trimmed within 95% of the reference.
sort_fasta() - Generates a list of reads, sorted by length.
filter_cluster_size() - Generates a list of reads filtered to a cluster size -- NONFUNCTIONAL
write_to_fasta() - Is able to take a list of reads generated by the previous three methods, and write them to a fasta file. 
first_consensus() - Runs all of the steps involved with generating a consensus.

"""


from Bio import SeqIO
import os
import pysam
import raw_read_merger as rrm
import setup_methods as setup


def basecall_command(basecaller_path, pod5_path, out_path, out_name):
    """
    Basecall_command generates a command to basecall based on dorado.
    
    Parameters:
    basecaller_path: path to the basecaller, as str
    pod5_path: path to the pod5 file to be basecalled, as str
    out_path: path to the output directory, as str
    out_name: name the basecalled fq file will be given, as str
    
    Returns:
    a command string.
    """
    # Currently only supports Dorado
    cmd = "{} basecaller hac --no-trip --emit-fastq {} > {}{}.fq".format(basecaller_path, pod5_path, out_path, out_name)
    return cmd


def map_to_reference(mapper_path, reference_path, basecall_path, out_path, out_name):
    """
    map_to_reference generates a command to use minimap2 to align the basecall with
    a reference sequence.
    
    Parameters:
    mapper_path: path to minimap2 as str
    reference_path: path to reference fasta (typically the barcodes) as str
    basecall_path: path to basecalled .fq file, as str
    out_path: path to the output directory, as str
    out_name: name the output sam file will be given, as str
    """
    # Currently only supports minimap2
    cmd = "{} -ax map-ont --score-N 0 --MD --min-dp-score 10 {} {} > {}{}.sam".format(mapper_path, reference_path, basecall_path, out_path, out_name)
    return cmd


def read_trim(sam_path):
    """
    read_trim takes in a samfile and returns a list of the reads
    in that sam file, with the query name and alignment sequence,
    so long as they are mapped and >=95% of the reference length.
    
    Parameters:
    sam_path: path to the sam file in question as a string.
    
    Returns:
    list of queries and alignments as a string.
    """
    # Sam path is the basecalled to reference
    output_list = []
    
    # open the alignment sam using pysam, open the fasta path as a fasta file
    with pysam.AlignmentFile(sam_file_path, 'r') as samfile:
        
        # for each read in the samfile,
        for read in samfile.fetch():
            
            # Check that the read is mapped
            if (not read.is_unmapped):
                
                # Get the reference sequence length and the alignment length
                reference_length = samfile.get_reference_length(read.reference_name)
                aligned_length = read.reference
                
                # if the aligned length is greater or equal to 95% of the reference length,
                if aligned_length >= reference_length * .95:
                    
                    # append it to the output.
                    output_list.append(f">{read.query_name}\n{read.query_alignment_sequence}\n")
    
    # return the output list
    return output_list


# How to validate the read_trim worked?

def sort_fasta(fasta_path):
    """
    sort_fasta takes in a fasta filepath and sorts it by length.
    
    Parameters:
    fasta_path: a path to a trimmed fasta file.

    
    Returns:
    a list of the records, sorted by length.
    """
    # get SeqRecord iterator as list by parsing the fasta file and passing fasta format.
    records = list(SeqIO.parse(fasta_path, "fasta"))
    
    # Sort the records by length using in-built sorting by sequence length.
    sorted_records = sorted(records, key=lambda x: len(x.seq))
    
    # create an empty list to hold the records to be output.
    output_records = []
    
    # return the sorted_records list
    return sorted_records


def vsearch_command(vsearch_path, fasta_path, out_path, out_name, sim_id):
    """
    vsearch_command takes in a fasta path, a similarity value, an output_path, and an output filename,
    and generates a command to perform clustering on the fasta file.
    
    Parameters:
    vsearch_path: path to vsearch as a string.
    fasta_path: path to the fasta file in question, as a string.
    out_path: path to output the final consensus fasta.
    out_name: filename for the fasta file. 
    sim_id: float value representing how similar the centroids can be (between 0 and 1)
    
    Returns: 
    command to perform vsearch with given directories as a string.
    """
    
    # Generate output files for the clusterfile and clusterinfo.
    clusterfile = out_path + 'clusters.fasta'
    clusterinfo = out_path + 'cluster_info.uc'
    
    # Generate the command.
    cmd = "{} --cluster_fast {} --id --centroids {} --uc {} --clusterout_sort --consout {}{}.fasta".format(vsearch_path, fasta_path, sim_id, clusterfile, clusterinfo, out_path, out_name)
    
    return cmd
            
    
def filter_cluster_size(fasta_path, threshold=100):
    """
    filter_cluster_size takes in a fasta filepath and a threshold,
    and removes all clusters that are not within that size threshold.
    
    Parameters:
    fasta_path: path to clustered/consensus fasta file, as string.
    threshold: int value representing minimum size. Default is 100.
    
    Returns:
    a list of strings containing the record id and sequence.
    """
    # create a list to store filtered records
    filtered_records = []
    
    # parse through the passed fasta's records
    for record in SeqIO.parse(fasta_path, "fasta"):
    
        # split the description of the record by semicolon
        parsed_record = record.description.split(';')
        
        # Check that the parsed record contains more than one part, get the second segment,
        # and check it starts with the string 'seqs'
        if len(parsed_record) > 1 and parsed_record[1].startswith('seqs='):
            
            # Get the size of the sequence
            size = int(parsed_record[1].split('=')[1])
            
            # if the size is larger than the threshold,
            if size > threshold:
                
                # add it to the filtered records.
                filtered_records.append(f">{record.id}\n{record.seq}")
    
    return filtered_records
    
    
def write_to_fasta(out_path, out_name, list_data):
    """
    write_to_fasta takes in an output path and file name, as well as a list
    of data to be written, and writes that data out as a fasta file at that
    path.
    
    Parameters:
    out_path: filepath to output directory, as str.
    out_name: name for the fasta file, as str.
    list_data: a list of the data to be written, formatted with each value
               being ">{id}\n{sequence}"
    
    Returns:
    the final path to the output fasta.
    """
    # create the output filename.
    out_file = out_path + out_name + ".fasta"
    
    # open the output file in write mode.
    with open(out_file, 'w') as output_file:
        
        # write each value in the fasta to a new line. 
        output_file.write("\n".join(list_data))
        
    # return the output filepath.
    return output
        

def medaka_consensus_command(medaka_path, trim_fasta, filtered_fasta, out_path):
    """
    medaka_consensus_command takes in a filepath for medaka, a trimmed fasta file,
    a filtered fasta, an output filepath, and then creates a consensus
    from that fasta file.
    
    Parameters:
    medaka_path: path, as str, to medaka_consensus
    trim_fasta: path, as str, to trimmed fasta file
    filtered_fasta: path, as str, to filtered fasta file
    out_path: path, as str, to output directory
    """

    # Generate the command.
    cmd = "{} -i {} -d {} -o {} -m r1041_e82_400bps_hac_v4.2.0 -f -b 300".format(medaka_path, trim_fasta, filtered_fasta, out_path)
    
    return cmd


def first_consensus(working_dir, reads, barcode_fasta):
    """
    first_consensus takes in working directory, reads, and a barcode fasta,
    and runs the steps needed to generate a first-pass consensus with no
    xenobases.
    """
    
    # Defualt filenames:
    p5_fname = "merged"
    dorado_path = "dorado" # Should be variable 
    basecall_fname = 'basecall' # fq file
    minimap2_path = 'minimap2' # should be variable
    aligned_bc_fname = 'bc_aligned' # SAM file
    trimmed_fname = 'trimmed' # Fasta 
    sorted_fname = 'sorted' # Fasta
    vsearch_path = 'vsearch' # should be variable
    vs_cons_fname = 'cons' # Fasta
    filtered_fname = 'represented_seq' # Fasta
    medaka_path = 'medaka_consensus' # should be variable
    polished_fname = 'polished_consensus' # Fasta


    #----------Setup----------------------#
    # Set up the working directory 0
    #             basecall_directory, 1
    #             fasta_directory, 2
    #             merged_pod5, 3
    #             rough_consensus_output, 4
    #             xf_consensus_output 5
    directories_list = setup.setup_directory_system(working_dir)

    # Using RRM, generate the pod5 from the data directory
    rrm.generate_merged_pod5(reads,
                             directories_list[3],
                             p5_fname)

    #File path string for the merged pod5
    merged_pod5_path = directories_list[3] + fname + '.pod5'

    #-------Basecalling and Sorting ---------#
    # Generate the dorado basecall command 
    bccmd = basecall_command(dorado_path,
                             merged_pod5_path,
                             directories_list[1],
                             basecall_fname)
    # Run the basecall command
    st = os.system(bccmd)

    # Filepath string for the basecalled fq 
    basecalled_path = directories_list[1] + basecall_name + '.fq'

    # use minimap2 to align the basecalled to the basecalled fq
    map2refcmd = map_to_reference(minimap2_path,
                                  barcode_fasta,
                                  basecalled_path,
                                  directories_list[1],
                                  aligned_bc_name)
    # Run the minimap2 command
    st = os.system(map2refcmd)

    #--------Trimming and Sorting Steps----------#
    # Filepath string for the sam file.
    samfile_path = directories_list[1] + aligned_bc_name + '.sam'

    # trim down the samfile to a trimmed fasta using default of 95% margin
    read_trims_list = read_trim(samfile_path)
    trimmed_fasta_path = write_to_fasta(directories_list[2],
                                        trimmed_fname,
                                        read_trims_list)

    # Sort the trimmed fasta, write it out.
    sorted_records_list = sort_fasta(trimmed_fasta_path)
    sorted_fasta_path = write_to_fasta(directories_list[2],
                                       sorted_fname,
                                       sorted_records_list)

    #--------Vsearch Steps-------------#
    # Generate and use vsearch on the fasta, round 1 at 85%:
    vscmd = vsearch_command(vsearch_path,
                            sorted_fasta_path,
                            directories_list[2],
                            vs_cons_fname+'85',
                            .85)
    st = os.system(vscmd)

    # Round two, 90%
    vscmd = vsearch_command(vsearch_path,
                            directories_list[2] + vs_cons_fname+'85' + '.fasta',
                            directories_list[2],
                            vs_cons_fname+'90',
                            .90)
    st = os.system(vscmd)
    
    # Round three, 95%
    vscmd = vsearch_command(vsearch_path,
                            directories_list[2] + vs_cons_fname+'90' + '.fasta',
                            directories_list[2],
                            vs_cons_fname+'95',
                            .95)
    st = os.system(vscmd)
    
    #--------Filtering Steps -----------------# 
    # filepath string for the vsearch fasta
    vsearch_cons_path = directories_list[2] + vs_cons_fname+'95'+ '.fasta'

    # METHOD IS CURRENTLY INVALID
    # filter the clustering fasta, and then write it out.
    #filtered_list = filter_cluster_size(vsearch_cons_path)
    #filtered_fasta_path = write_to_fasta(directories_list[2],
    #                                       filtered_fname,
    #                                       filtered_list)

    
    #--------------Run Medaka ---------------------#
    # Generate the medaka command to perform consensus
    mdkacmd = medaka_consensus_command(medaka_path,
                                          trimmed_fasta_path,
                                          vsearch_cons_path,
                                          directories_list[4])
    st = os.system(mdkacmd)

    # filepath string for the medaka consensus:
    medak_cons_path = directories_list[4] + 'consensus.fasta'
    
    # return the path to the polished fasta.
    return medak_cons_path


def main():
    in_w_dir = input("Please provide working directory path: ")
    in_r_dir = input("Please provide read directory path: ")
    in_f_dir = input("Please provide reference fasta directory path: ")
    
    consensus_path = first_consensus(in_w_dir, in_r_dir, in_f_dir)
    
    print("Consensus fasta located at: {}").format(consensus_path)
    
    
if __name__ == '__main__':
    main()
    